class Node {
  constructor(){
    this.parentNode = null;
    this.childNodes = [];
    this.ownerDocument = null;
  }
  appendChild(node){
    if(node.parentNode){
      const idx = node.parentNode.childNodes.indexOf(node);
      if(idx >= 0) node.parentNode.childNodes.splice(idx, 1);
    }
    node.parentNode = this;
    node.ownerDocument = this.ownerDocument || this;
    this.childNodes.push(node);
    return node;
  }
  removeChild(node){
    const idx = this.childNodes.indexOf(node);
    if(idx >= 0){
      this.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
    return node;
  }
}

class TextNode extends Node {
  constructor(text){
    super();
    this.textContent = text;
  }
}

function matchesClass(el, className){
  return (` ${el.className || ''} `).includes(` ${className} `);
}

class Element extends Node {
  constructor(tag){
    super();
    this.tagName = tag.toUpperCase();
    this.attributes = new Map();
    this.style = {};
    this.eventListeners = new Map();
    this.id = '';
    this.className = '';
  }
  setAttribute(name, value){
    const v = String(value);
    if(name === 'id'){ this.id = v; }
    if(name === 'class'){ this.className = v; }
    this.attributes.set(name, v);
  }
  getAttribute(name){
    if(name === 'id') return this.id;
    if(name === 'class') return this.className;
    return this.attributes.get(name) ?? null;
  }
  appendChild(node){
    super.appendChild(node);
    if(node.ownerDocument) node.ownerDocument._register(node);
    return node;
  }
  get textContent(){
    return this.childNodes.map((n)=> n.textContent ?? '').join('');
  }
  set textContent(value){
    this.childNodes = [];
    if(value !== undefined && value !== null){
      this.appendChild(new TextNode(String(value)));
    }
  }
  addEventListener(type, handler){
    if(!this.eventListeners.has(type)) this.eventListeners.set(type, new Set());
    this.eventListeners.get(type).add(handler);
  }
  removeEventListener(type, handler){
    this.eventListeners.get(type)?.delete(handler);
  }
  dispatchEvent(evt){
    evt.target = this;
    const handlers = this.eventListeners.get(evt.type) || [];
    for(const handler of handlers){ handler.call(this, evt); }
  }
  click(){ this.dispatchEvent({ type: 'click' }); }
  querySelector(selector){
    return querySelectorFrom(this, selector);
  }
}

class Document extends Element {
  constructor(){
    super('#document');
    this.ownerDocument = this;
    this.documentElement = this;
    this.body = new Element('body');
    this.body.ownerDocument = this;
    this.childNodes = [this.body];
    this._idIndex = new Map();
  }
  _register(node){
    if(node.id){ this._idIndex.set(node.id, node); }
    if(node.childNodes){
      for(const child of node.childNodes){ this._register(child); }
    }
  }
  createElement(tag){
    const el = new Element(tag);
    el.ownerDocument = this;
    return el;
  }
  createTextNode(text){
    const node = new TextNode(text);
    node.ownerDocument = this;
    return node;
  }
  getElementById(id){
    if(this._idIndex.has(id)) return this._idIndex.get(id);
    return findById(this.body, id);
  }
  querySelector(selector){
    return querySelectorFrom(this.body, selector);
  }
}

function findById(root, id){
  if(!root) return null;
  if(root.id === id) return root;
  for(const child of root.childNodes || []){
    const found = findById(child, id);
    if(found) return found;
  }
  return null;
}

function querySelectorFrom(root, selector){
  if(selector.startsWith('#')){
    const id = selector.slice(1);
    return findById(root, id);
  }
  if(selector.startsWith('.')){
    const cls = selector.slice(1);
    return findByClass(root, cls);
  }
  return findByTag(root, selector.toUpperCase());
}

function findByClass(root, className){
  if(root instanceof Element && matchesClass(root, className)) return root;
  for(const child of root.childNodes || []){
    const found = findByClass(child, className);
    if(found) return found;
  }
  return null;
}

function findByTag(root, tag){
  if(root instanceof Element && root.tagName === tag) return root;
  for(const child of root.childNodes || []){
    const found = findByTag(child, tag);
    if(found) return found;
  }
  return null;
}

class Window {
  constructor(document){
    this.document = document;
  }
}

export class JSDOM {
  constructor(){
    const document = new Document();
    this.window = new Window(document);
  }
}
